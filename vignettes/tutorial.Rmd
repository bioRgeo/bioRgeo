---
title: "Tutorial"
author: "Pierre Denelle"
date: "`r Sys.Date()`"
output: 
  html_vignette:
    toc: true
    toc_depth: 2
    number_sections: true
  word_vignette:
    toc: true
    toc_depth: 2
    number_sections: true
vignette: >
%\VignetteIndexEntry{Tutorial for bioRgeo R package}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8} 
 editor_options: 
 chunk_output_type: console
---

<style>
body {
text-align: justify}
</style>

# 1. Overview

In the following vignette, we show how *bioRgeo* package works. We use a simulated dataset of virtual species distributed across sites to illustrate how we can detect communities, i.e. groups of sites that are closely related regarding their species composition.

To detect these large-scale communities, *bioRgeo* uses a variety of methods, ranging from bipartite network modularity to classical clustering. Each method enables identifying groups of sites that are more similar between each other than compared with the rest of the sites available.

Our example and package is mostly designed for ecologists interested in detecting large-scale patterns in the distribution of species across environments but it can also be used in other fields interested in the detection of large-scale patterns.

The principle of the package is illustrated by the following figure.

```{r package_scheme, fig.label = "Workflow of the package."}
knitr::include_graphics("../figures/Bioregionalization_scheme3.png")
```

## 1.1. Glossary
Some terms that design the types of inputs this package needs and their associated format are repeatedly used in this vignette. We here define how we use these terms.

*contingency table* a matrix containing the distribution of species across sites. The species are in columns and the sites in rows. This table is the first possible input of the *bioRgeo* functions.

*long format table* a data.frame in which each row indicates the occurrence of a species in a given site. The sites are therefore replicated as many times as the number of species they contain. A third column containing the abundances of species can be added. Without this column, every species present in this table is supposed to be present in the associated site. This format is the second possible input of the *bioRgeo* functions.

*adjacency table* a square matrix that contains the occurrences of species within sites. Both sites and species are in rows and columns. In case of a bipartite network, there are no links between the same type of nodes, meaning that the adjacency matrix is filled with a lot of 0. For more details, see [here](https://en.wikipedia.org/wiki/Adjacency_matrix).

Since *bioRgeo* relies on two possible inputs, we let the option to users to switch from one format to the other using either *contingency()* or *contingency_to_dataframe()* functions as illustrated in the following figure: 

```{r input_figure, fig.label = "Two possible inputs.", fig.width = 4, fig.height = 4}
knitr::include_graphics("../figures/20200225_bioRgeo_inputs.png")
```

Several functions of the package necessitate to define the structure of the input.

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      fig.width = 8, fig.height = 8)
# Packages --------------------------------------------------------------------
suppressPackageStartupMessages({
  suppressWarnings({
    library(bioRgeo)
    library(dplyr)
    library(sf)
    library(ggplot2)
    library(cowplot)
    library(igraph)
    library(RColorBrewer)
  })
})

options(tinytex.verbose = TRUE)

```

## 1.2 Virtual dataset
To illustrate how *bioRgeo* works, we use a virtual dataset. This dataset comes with the installation of the package and can be loaded using the following command:

```{r loading_virtual_data}
data("virtual_sp")
```

This command returns a list of three elements. The first element corresponds to the virtual dataset. The second and third element correspond to the partition found by the OSLOM algorithm (see below).
The virtual dataset has been constructed by simulating the response curves of 100 species to a virtual raster.
The virtual raster contains 10000 cells and was simulated using `gstat` R package. See [here](http://santiago.begueria.es/2010/10/generating-spatially-correlated-random-fields-with-r/) for details.

After loading the virtual data, and since each site has XY coordinates, we can plot the raster of the virtual environment layer.

```{r plot_virtual_raster, fig.width = 4, fig.height = 4}
# Only species data.frame
sp_df <- virtual[[1]]

# Plot of environmental values
sp_df %>%
  distinct(site, .keep_all = TRUE) %>%
  ggplot(aes(x, y)) +
  geom_tile(aes(fill = env, color = env),
            alpha = 0.8, width = 1, height = 1) +
  scale_color_distiller("Value", palette = "RdYlBu") +
  scale_fill_distiller("Value", palette = "RdYlBu") + #OrRd
  coord_equal() +
  labs(title = "Environmental raster") +
  theme(panel.background = element_rect(fill = "transparent", colour = NA))

```

Based on this raster, we used the *virtualspecies* R package [(Leroy et al. 2015)](https://doi.org/10.1111/ecog.01388) to simulate a Gaussian response curve of 100 virtual species. The mean and standard deviation of the response function varied among species, drawing a continuum of generalist and specialist species.

The following figure illustrates a response curve for one virtual species:

```{r virtual_sp_response_curve, fig.label = "Example of response curve for one virtual species."}
knitr::include_graphics("../figures/sp_response_curve_example.jpeg")
```

For every species in every cell, we could derive a suitability index and produce suitability maps as shown below.
Species with suitability index inferior to 0.15 were arbitrarily set absent.

```{r virtual_sp_map, fig.label = "Example of suitability map for one virtual species."}
knitr::include_graphics("../figures/sp_suitability_example.jpeg")
```

In total, the 100 suitability maps of our virtual species are distributed like this:
```{r 100_suitabilities, fig.label = "100 suitability maps for the virtual species."}
knitr::include_graphics("../figures/100_suitability.jpeg")
```

See [here](http://borisleroy.com/virtualspecies/) for further information on the "virtualspecies* R package.

### 1.2.1. Code to generate the virtual data
The code to generate the virtual dataset is provided in the chunk below. This chunk is not run when loading the vignette, since the outputs are directly stored with the package.

```{r virtual_dataset, eval = FALSE}
library(gstat) # virtual rasters with autocorrelation
library(sp) # spatial plots
library(cowplot) # combining plots
library(ggplot2) # plot
library(raster)
library(virtualspecies) # simulate virtual species
library(dplyr)
library(bioRgeo)

## Virtual raster layer -------------------------------------------------------
# http://santiago.begueria.es/2010/10/generating-spatially-correlated-random-fields-with-r/

# XY coordinates
xy <- expand.grid(1:20, 1:20)
names(xy) <- c("x","y")
# Spatial model
g_ex <- gstat(formula = z ~ 1 + x + y, locations = ~ x + y, dummy = TRUE,
              beta = c(1, 0.01, 0.005), nmax = 20,
              model = vgm(psill = 0.025, range = 50, model = "Exp"))

# Four layers created
set.seed(1)
yy <- predict(g_ex, newdata = xy, nsim = 4)

# Plottind rasters
gridded(yy) = ~x+y

plot_grid(spplot(obj = yy[1]), spplot(obj = yy[2]),
          spplot(obj = yy[3]), spplot(obj = yy[4]),
          nrow = 2)

# Data.frame with pixel and environmental value
env_dat <- cbind(yy[2]@coords, yy[2]@data)
env_dat$site <- paste0("site", 1:nrow(env_dat))

colnames(env_dat) <- c("x", "y", "env", "site")

# Environmental raster
env_raster <- env_dat[, c("x", "y", "env")]
coordinates(env_raster) <- ~ x + y
gridded(env_raster) <- TRUE
env_raster <- raster(env_raster)

## Virtual species ------------------------------------------------------------
# http://borisleroy.com/files/virtualspecies-tutorial.html

# Generating 100 species with mean all along Bio1 gradient
env_value <- env_dat$env
mean_gdt <- sort(rep(seq(min(env_value), max(env_value), length.out = 10),
                     10))
sd_gdt <- rep(seq(var(env_value), 2*var(env_value), length.out = 10), 10)

# Generating 100 species with 500 occurrences
sampled_points <- rep(500, length(env_dat$env))

# Example of response curve
param_i <- formatFunctions(
  env = c(fun = "dnorm", mean = mean_gdt[1], sd = sd_gdt[100]))
# Generation of the virtual species
sp_i <- generateSpFromFun(raster.stack = env_raster,
                          parameters = param_i, plot = TRUE)
plotResponse(sp_i)

sp_df <- c()
for (i in 1:100){
  param_i <- formatFunctions(
    env = c(fun = "dnorm", mean = mean_gdt[i], sd = sd_gdt[i]))
  # Generation of the virtual species
  sp_i <- generateSpFromFun(raster.stack = env_raster,
                            parameters = param_i, plot = TRUE)
  # plotResponse(sp_i)
  
  # Conversion to presence/absence
  pa_i <- convertToPA(sp_i, plot = FALSE, beta = 0.7)
  
  occ_i <- data.frame(sp = paste0("sp", i),
                      rasterToPoints(pa_i$suitab.raster),
                      pa = data.frame(rasterToPoints(pa_i$pa.raster))$layer)
  colnames(occ_i)[colnames(occ_i) == "layer"] <- "suitab"
  
  # Binding results
  sp_df <- rbind(sp_df, occ_i)
  print(i)
}

# Add site and environment columns
sp_df <- left_join(sp_df, env_dat, by = c("x", "y"))

```

# 2. Community detection
The core of the package relies on the aggregation of several methods that
perform community detection based on distinct methods.

According to the preference of the user, we can convert the input data.frame into a contingency table, using the *contingency()* function:

```{r contingency_matrix}
sp_mat <- contingency(sp_df[which(sp_df$pa != 0), ],
                      "site", "sp", ab = NULL, binary = TRUE)
knitr::kable(sp_mat[1:5, 1:5])

# With weights
sp_mat_w <- contingency(sp_df, "site", "sp", ab = "suitab", binary = FALSE)
knitr::kable(sp_mat_w[1:5, 1:5])
```

## 2.1. Bipartite networks
Networks are called bipartite when they are constituted by two types of nodes.
Each type of node can only be linked with the other type. For example, if
species occur in sites, sites and species constitute two types of nodes and
an occurrence of a species within a site describes a link between these two
nodes.

### igraph
Several algorithms to detect community within bipartite networks. Several of
them are implemented within the *igraph* package.

```{r bipartite}
# With fastgreedy
bip <- algo_bipartite(dat = sp_mat, algo = "greedy", weight = FALSE)

# fastgreedy, input data frame
bip_df <- algo_bipartite(dat = sp_df[which(sp_df$pa > 0), ],
                         algo = "greedy",
                         weight = FALSE, input = "data frame", site = "site",
                         sp = "sp", ab = NULL)

table(bip$module); table(bip_df$module)

# With Beckett algorithm
bip2 <- algo_bipartite(dat = sp_mat, algo = "LPAwb", weight = FALSE)

# With Infomap
bip_infomap <- algo_bipartite(dat = sp_mat, algo = "infomap", weight = FALSE)

# With Louvain
bip_louvain <- algo_bipartite(dat = sp_mat, algo = "louvain", weight = FALSE)

# With Walktrap
bip_walktrap <- algo_bipartite(dat = sp_mat, algo = "walktrap", weight = FALSE)

# Only sites
bip_site <- bip %>%
  filter(cat == "site") %>%
  rename(site = node) %>%
  dplyr::select(site, module)

bip_site2 <- bip2 %>%
  filter(cat == "site") %>%
  rename(site = node) %>%
  dplyr::select(site, module)

bip_site_infomap <- bip_infomap %>%
  filter(cat == "site") %>%
  rename(site = node) %>%
  dplyr::select(site, module)

bip_site_louvain <- bip_louvain %>%
  filter(cat == "site") %>%
  rename(site = node) %>%
  dplyr::select(site, module)

bip_site_walktrap <- bip_walktrap %>%
  filter(cat == "site") %>%
  rename(site = node) %>%
  dplyr::select(site, module)

```

### Infomap

```{r infomap}

po <- run_infomap(
  dat = sp_df[which(sp_df$pa > 0), ], site = "site", sp = "sp",
  ab = NULL,
  saving_directory = "D:/Irstea/CarHab/Bioregionalization_extra",
  N = 10)

res <- readRDS("D:/Irstea/CarHab/Bioregionalization_extra/dat_infomap.rds")
table(res[!duplicated(res$site), "module"])
```

## Projected networks

A projected network considers the similarity between each pair of nodes. In
our case, nodes can represent different sites that are linked together
according the proportion of species they share together.

### Projection of the network

To project the network, we can use the *project_network()* function.

```{r projection}
sp_proj <- project_network(sp_mat, similarity = "simpson")
sp_proj <- sp_proj[, c("id1", "id2", "simpson")]

knitr::kable(head(sp_proj))

# With data frame input
sp_proj_df <- project_network(sp_df[which(sp_df$pa != 0), ],
                              similarity = "simpson", input = "data frame",
                              site = "site", sp = "sp")
sp_proj_df <- sp_proj_df[, c("id1", "id2", "simpson")]

knitr::kable(head(sp_proj_df))

# Bray-Curtis dissimilarity can take into account abundances of species
sp_proj_w <- project_network(sp_mat_w, similarity = "bray")
sp_proj_w <- sp_proj_w[, c("id1", "id2", "bray")]

knitr::kable(head(sp_proj_w))
```

### Order Statistics Local Optimization Method (OSLOM)

Running OSLOM. tp files containing the modularity results are directly stored
within the virtual dataset, but the following chunk can be run independently.

Output of OSLOM are stored in a chosen directory and can be import into R with
the command `readRDS()`.

Code compiled, original from http://www.oslom.org
Lancichinetti et al. (2011)

```{r run_OSLOM, eval = FALSE}
run_oslom(sp_proj, n_runs = 5, t_param = 0.1, cp_param = 0.5,
          saving_directory = "D:/Irstea/CarHab/Bioregionalization_extra")

res <- readRDS("D:/Irstea/CarHab/Bioregionalization_extra/tp.rds")
file.rename("D:/Irstea/CarHab/Bioregionalization_extra/tp.rds",
            "D:/Irstea/CarHab/Bioregionalization_extra/tp_binary.rds")
# With weights
run_oslom(sp_proj_w, n_runs = 5, t_param = 0.1, cp_param = 0.5,
          saving_directory = "D:/Irstea/CarHab/Bioregionalization_extra/")

res_w <- readRDS("D:/Irstea/CarHab/Bioregionalization_extra/tp.rds")

```

oslom_output() functions converts the OSLOM .tp file into a list.

```{r conversion_OSLOM}
# Format OSLOM output into a data.frame
oslom_vignette <- oslom_output(virtual[[2]], sp_mat)
# With weights
oslom_vignette_w <- oslom_output(virtual[[3]], sp_mat_w)

print(paste0("Number of bioregions detected = ",
             length(unique(oslom_vignette$bioregion)),
             " ; and with weights: ",
             length(unique(oslom_vignette_w$bioregion))))

```

## Clustering

Other methods to detect communities use more classical clustering approaches.
For example, k-means clustering aims at partitionning *n* observations into
*k* clusters in which each observation belongs to the cluster with the nearest
mean.

Agglomerative Hierarchical Clustering.

See https://towardsdatascience.com/the-5-clustering-algorithms-data-scientists-need-to-know-a36d136ef68
to add more methods.

```{r cluster}
# CA_res <- CA_cluster(sp_mat)
ward_res <- cluster(sp_mat, method = "ward.D2", n_clust = 4)

dbscan_res <- cluster(sp_mat, method = "dbscan")

gmm_res <- cluster(sp_mat, method = "gmm")

```


# Comparison of different bioregionalizations

If sites have coordinates, we can apply several functions to compare how the
distinct bioregions are segregated through space.

## Maps

```{r map_virtual_dataset}

plot_grid(
  # Plot of OSLOM bioregions
  sp_df %>%
    left_join(oslom_vignette, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(bioregion), color = as.factor(bioregion)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    # scale_color_viridis_d("Bioregions", option = "E") +
    # scale_fill_viridis_d("Bioregions", option = "E") +
    coord_equal() +
    labs(title = "OSLOM bioregions") +
    theme(panel.background = element_rect(fill = "transparent",
                                          colour = "black")),
  
  # Plot of Ward bioregions
  sp_df %>%
    left_join(ward_res, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(cluster), color = as.factor(cluster)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Ward bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of DBSCAN bioregions
  sp_df %>%
    left_join(dbscan_res, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(cluster), color = as.factor(cluster)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "DBSCAN bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of GMM bioregions
  sp_df %>%
    left_join(gmm_res, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(cluster), color = as.factor(cluster)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "GMM bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of fastgreedy bioregions
  sp_df %>%
    left_join(bip_site, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(module), color = as.factor(module)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Bipartite greedy bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of LPAwb bioregions
  sp_df %>%
    left_join(bip_site2, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(module), color = as.factor(module)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "LPAwb+ greedy bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of Infomap bioregions
  sp_df %>%
    left_join(bip_site_infomap, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(module), color = as.factor(module)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Infomap bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of Louvain bioregions
  sp_df %>%
    left_join(bip_site_louvain, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(module), color = as.factor(module)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Louvain bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of Walktrap bioregions
  sp_df %>%
    left_join(bip_site_walktrap, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(module), color = as.factor(module)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Walktrap bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  nrow = 3)

```

## Coherent areas

```{r comparison, eval = TRUE}
# Gather all the bioregionalizations
all_bioregions <- sp_df %>%
  select(site, x, y, env) %>%
  distinct(site, .keep_all = TRUE) %>%
  left_join(oslom_vignette, by = "site") %>% # add OSLOM
  rename(oslom = bioregion) %>%
  left_join(ward_res, by = "site") %>% # add Ward
  rename(ward = cluster) %>%
  left_join(bip_site, by = "site") %>% # add greedy
  distinct(site, .keep_all = TRUE) %>%
  rename(greedy = module) %>%
  left_join(bip_site2, by = "site") %>% # add LPAwb
  distinct(site, .keep_all = TRUE) %>%
  rename(lpawb = module) %>%
  left_join(bip_site_infomap, by = "site") %>% # add infomap
  distinct(site, .keep_all = TRUE) %>%
  rename(infomap = module)

# Test of comparison function
all100 <- comparison(all_bioregions, bio_col = c(5:9))

# Comparison of maps
plot_grid(
  # Plot of OSLOM bioregions
  sp_df %>%
    left_join(oslom_vignette, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(bioregion), color = as.factor(bioregion)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    # scale_color_viridis_d("Bioregions", option = "E") +
    # scale_fill_viridis_d("Bioregions", option = "E") +
    coord_equal() +
    labs(title = "OSLOM bioregions") +
    theme(panel.background = element_rect(fill = "transparent",
                                          colour = "black")),
  
  # Identical pairs of plots
  all100 %>%
    left_join(all_bioregions[, c("site", "x", "y")], by = c("id1" = "site")) %>%
    distinct(id1, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(uni), color = as.factor(uni)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_viridis_d("Bioregions", option = "E") +
    scale_fill_viridis_d("Bioregions", option = "E") +
    # scale_color_brewer("Bioregions", palette = "Paired") +
    # scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Identical bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of Ward bioregions
  sp_df %>%
    left_join(ward_res, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(cluster), color = as.factor(cluster)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Ward bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of fastgreedy bioregions
  sp_df %>%
    left_join(bip_site, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(module), color = as.factor(module)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Bipartite greedy bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of LPAwb bioregions
  sp_df %>%
    left_join(bip_site2, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(module), color = as.factor(module)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "LPAwb+ greedy bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  # Plot of Infomap bioregions
  sp_df %>%
    left_join(bip_site_infomap, by = "site") %>%
    distinct(site, .keep_all = TRUE) %>%
    ggplot(aes(x, y)) +
    geom_tile(aes(fill = as.factor(module), color = as.factor(module)),
              alpha = 0.8, width = 1, height = 1) +
    scale_color_brewer("Bioregions", palette = "Paired") +
    scale_fill_brewer("Bioregions", palette = "Paired") +
    coord_equal() +
    labs(title = "Infomap bioregions") +
    theme(panel.background = element_rect(fill = "transparent", colour = NA)),
  
  nrow = 2)

# Plot with tiles
all100 %>%
  left_join(all_bioregions[, c("site", "x", "y")], by = c("id1" = "site")) %>%
  distinct(id1, .keep_all = TRUE) %>%
  st_as_sf(coords = c("x", "y")) %>%
  group_by(pair_bio) %>%
  st_cast("MULTIPOINT") %>%
  summarise() %>%
  ggplot() +
  geom_sf(aes(color = as.factor(pair_bio)))
geom_tile(aes(fill = as.factor(pair_bio), color = as.factor(pair_bio)),
          alpha = 0.8, width = 1, height = 1)

```

```{r autocorrelation, eval = TRUE}

## Autocorrelation
# https://mgimond.github.io/Spatial/spatial-autocorrelation-in-r.html
library(sp)
all_bioregions_sp <- all_bioregions
all_bioregions_sp <- all_bioregions_sp[complete.cases(all_bioregions_sp), ]
coordinates(all_bioregions_sp) <- ~x+y

all_bioregions_sp$oslom <- as.numeric(as.character(all_bioregions_sp$oslom))
all_bioregions_sp$ward <- as.numeric(as.character(all_bioregions_sp$ward))
all_bioregions_sp$greedy <- as.numeric(as.character(all_bioregions_sp$greedy))
all_bioregions_sp$lpawb <- as.numeric(as.character(all_bioregions_sp$lpawb))
all_bioregions_sp$infomap <- as.numeric(as.character(all_bioregions_sp$infomap))

coo <- coordinates(all_bioregions_sp)
# S.dist  <-  spdep::dnearneigh(coo, 0, 100)
# lw <- spdep::nb2listw(S.dist, style="W",zero.policy=T) 
# MI  <-  spdep::moran.mc(all_bioregions_sp$oslom, lw, nsim=599,zero.policy=T)
# plot(MI, main = "", las = 1) 

bws <- c(3, 4, 6, 9, 12, 18, 24)
moran_oslom <- lctools::moransI.v(coo, bws, all_bioregions_sp@data$oslom,
                                  plot = FALSE)
moran_ward <- lctools::moransI.v(coo, bws, all_bioregions_sp@data$ward,
                                 plot = FALSE)
moran_greedy <- lctools::moransI.v(coo, bws, all_bioregions_sp@data$greedy,
                                   plot = FALSE)
moran_lpawb <- lctools::moransI.v(coo, bws, all_bioregions_sp@data$lpawb,
                                  plot = FALSE)
moran_infomap <- lctools::moransI.v(coo, bws, all_bioregions_sp@data$infomap,
                                    plot = FALSE)

all_moran <-
  rbind(data.frame(
    algo = "oslom", k = moran_oslom[, "k"],
    moran = moran_oslom[, "Moran's I"]),
    data.frame(algo = "ward", k = moran_ward[, "k"],
               moran = moran_ward[, "Moran's I"]),
    data.frame(algo = "ward", k = moran_ward[, "k"],
               moran = moran_greedy[, "Moran's I"]),
    data.frame(algo = "greedy", k = moran_greedy[, "k"],
               moran = moran_lpawb[, "Moran's I"]),
    data.frame(algo = "infomap", k = moran_infomap[, "k"],
               moran = moran_infomap[, "Moran's I"])
  )

ggplot(all_moran, aes(k, moran)) +
  geom_line(aes(color = as.factor(algo))) +
  geom_point(aes(color = as.factor(algo))) +
  scale_color_viridis_d("Method") +
  labs(x = "# of neighbours", y = "Moran's I") +
  theme_classic() +
  theme(panel.border = element_rect(fill= NA, color = "black"))

```

## Pairs of maps
We can as well compare each pair of bioregion to each other.

```{r pair_sabre, eval = FALSE}
# sabre package: test between oslom and ward
# Spatial Association Between REgionalizations
library(sabre)
library(sf)

bioregions_sf <- st_as_sf(all_bioregions, coords = c("x", "y")) %>%
  st_cast(to = "MULTILINESTRING")

po <- vmeasure_calc(x = bioregions_sf, x_name = oslom,
                    y = bioregions_sf, y_name = ward)

# Groups of pixels through the different methods
list_group_oslom <- by(all_bioregions$site, all_bioregions$oslom, identity)
list_group_oslom <- lapply(list_group_oslom, as.character)

list_group_ward <- by(all_bioregions$site, all_bioregions$ward, identity)
list_group_ward <- lapply(list_group_ward, as.character)

list_group_greedy <- by(all_bioregions$site, all_bioregions$greedy, identity)
list_group_greedy<- lapply(list_group_greedy, as.character)

list_group_lpawb <- by(all_bioregions$site, all_bioregions$lpawb, identity)
list_group_lpawb <- lapply(list_group_lpawb, as.character)

list_group_infomap <- by(all_bioregions$site, all_bioregions$infomap, identity)
list_group_infomap <- lapply(list_group_infomap, as.character)

list_combined <- lapply(list_group_oslom, function(x) x[x %in% list_group_ward[[1]]])
list_combined <- lapply(list_combined, function(x) x[x %in% list_group_greedy[[1]]])
list_combined <- lapply(list_combined, function(x) x[x %in% list_group_lpawb[[1]]])
list_combined <- lapply(list_combined, function(x) x[x %in% list_group_infomap[[1]]])

# For one combination only
list1_oslom <-
  all_bioregions[which(all_bioregions$oslom == unique(all_bioregions$oslom)[1]),
                 "site"]
list1_ward <- all_bioregions[which(all_bioregions$ward == unique(all_bioregions$ward)[1]),
                             "site"]
list1_greedy <- all_bioregions[which(all_bioregions$greedy == unique(all_bioregions$greedy)[1]),
                               "site"]
list1_lpawb <- all_bioregions[which(all_bioregions$lpawb == unique(all_bioregions$lpawb)[1]),
                              "site"]
list1_infomap <- all_bioregions[which(all_bioregions$infomap == unique(all_bioregions$infomap)[1]),
                                "site"]

list1_combined <- list1_oslom[list1_oslom %in% list1_ward]
list1_combined <- list1_combined[list1_combined %in% list1_greedy]
list1_combined <- list1_combined[list1_combined %in% list1_lpawb]
list1_combined <- list1_combined[list1_combined %in% list1_infomap]

all_bioregions$combined <- NA
all_bioregions[which(all_bioregions$site %in% list1_combined), "combined"] <- "1"

```

# Structuration vs bioregionalizations

```{r structuration}
# 
nbopt <- sp_df %>%
  left_join(oslom_vignette, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "bioregion"] <- "oslom"

# Plot of Ward bioregions
nbopt <- nbopt %>%
  left_join(ward_res, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "cluster"] <- "ward"

# Plot of DBSCAN bioregions
nbopt <- nbopt %>%
  left_join(dbscan_res, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "cluster"] <- "dbscan"

# Plot of GMM bioregions
nbopt <- nbopt %>%
  left_join(gmm_res, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "cluster"] <- "gmm"

# Plot of fastgreedy bioregions
nbopt <- nbopt %>%
  left_join(bip_site, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "module"] <- "fastgreedy"

# Plot of LPAwb bioregions
nbopt <- nbopt %>%
  left_join(bip_site2, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "module"] <- "lpawb"

# Plot of Infomap bioregions
nbopt <- nbopt %>%
  left_join(bip_site_infomap, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "module"] <- "infomap"

# Plot of Louvain bioregions
nbopt <- nbopt %>%
  left_join(bip_site_louvain, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "module"] <- "louvain"

# Plot of Walktrap bioregions
nbopt <- nbopt %>%
  left_join(bip_site_walktrap, by = "site") %>%
  distinct(site, .keep_all = TRUE)
colnames(nbopt)[colnames(nbopt) == "module"] <- "walktrap"

# Import results
po <- data.frame(nbopt = length(unique(sp_df$opt)),
                 nb_oslom = length(unique(nbopt$oslom)),
                 nb_ward = length(unique(nbopt$ward)),
                 nb_dbscan = length(unique(nbopt$dbscan)),
                 nb_gmm = length(unique(nbopt$gmm)),
                 nb_fastgreedy = length(unique(nbopt$fastgreedy)),
                 nb_lpawb = length(unique(nbopt$lpawb)),
                 nb_infomap = length(unique(nbopt$infomap)),
                 nb_louvain = length(unique(nbopt$louvain)),
                 nb_walktrap = length(unique(nbopt$walktrap)))

pop <- tidyr::gather(po, bioregions, nb, contains("nb_"))

# Plot: number of unique topt vs variance of bioregions
ggplot(pop, aes(nbopt, nb)) +
  geom_boxplot() +
  labs(x = "Number of optimums", y = "Number of bioregions") +
  theme_classic() +
  theme(panel.border = element_rect(fill = "transparent"))

```

# Species' contributions

This part aims at evaluating the contributions of species to the different
bioregions created.

```{r contrib}
tmp <- left_join(sp_df[which(sp_df$pa > 0), ], oslom_vignette, by = "site")
# table(tmp$sp, tmp$bioregion)

scores <- contribute(dat = tmp, sp_col = "sp", site_col = "site",
                     bioregion_col = "bioregion")

```

The following figure illustrates how the rho score from Lenormand et al. 2019
is calculated.

```{r zscore_scheme, fig.label = "Principle of the zscore calculation."}
knitr::include_graphics("../figures/zscore_scheme.png")
```

$$
\rho_{ij} = \frac{n_{ij} - \frac{n_in_j}{n}}{\sqrt(\frac{n-n_j}{n-1}(1-\frac{n_j}{n})\frac{n_jn_i}{n})}
$$

Formula of Cz scores:

$$
P_{i} = 1 - \sum_{i = 1}^{N_m}{(\frac{k_{is}}{k_{i}})^2} 
$$

where Pi is the participation coefficient of node i, kis is the number of links of node i to region s, ki is the total number of links of node i and Nm is the total number of regions. We calculated the participation coefficient at each level of the biogeographical structure identified by Map Equation. 

$$
z_i = \frac{k_i - \overline{k_{si}}}{\sigma_{k_{si}}}
$$

The within-module degree z-score measures how well-connected
node i is to other nodes in the module.

# Interaction between bioregions

Following the equation of the rho score from above.

The interactions between the different bioregions can then be calculated following
these equations:

$$
\hat\rho_{ij}^{+} = {\rho_{ij}}_{\rho_{ij}>1.96}
$$
We normalize the rows:

$$
\hat\rho_{ij}^{+} = \frac{\rho_{ij}^{+}}{\sum_i\rho_{ij}^{+}}
$$

Finally, we determine for each bioregion how each set of species contributes
to it.

$$
\lambda_{jj'} = \frac{1}{|A_j|}\sum_{i \in A_{j}}\hat\rho_{jj'}^{+}
$$

```{r z_scores_dummy}

# 10 sites with species richness belonging to [1, 3]
set.seed(1)
sites <- sapply(paste0("site", seq(1:10)),
                function(x) rep(x, sample(c(1:3), 1)))
# Pool of 5 species distributed across the sites
species <- lapply(sites,
                  function(x) sample(paste0("sp", seq(1:5)), 
                                     length(x), replace = TRUE))
# 3 bioregions assigned randomly
bioregions <- sample(paste0("bio", seq(1:3)), length(sites), replace = TRUE)
bioregions <- data.frame(site = names(sites),
                         bioregion = bioregions)

# Conversion to data frame
fuzzy <- data.frame(site = as.character(unlist(sites)),
                    sp = as.character(unlist(species)))
fuzzy <- left_join(fuzzy, bioregions, by = "site")

table(fuzzy$sp, fuzzy$bioregion)

# Compute zscores
zscores <- zscore(fuzzy, sp_col = "sp", site_col = "site",
                  bioregion_col = "bioregion", output_format = "matrix")
zscores

# Interactions between bioregions
interact(input_network = "projected",
         dat = zscores, plot = TRUE, output_format = "matrix")

```

```{r lambda}
# tmp <- left_join(sp_df, oslom_vignette, by = "site")
tmp <- left_join(sp_df[which(sp_df$pa > 0), ], oslom_vignette, by = "site")
# table(tmp$sp, tmp$bioregion)

z_scores <- zscore(tmp, sp_col = "sp", site_col = "site",
                   bioregion_col = "bioregion", output_format = "dataframe")

top10 <- z_scores %>%
  group_by(bioregion) %>%
  top_n(n = 10, zscore) %>% # extract top 10
  mutate(rank = rank(-zscore, # ranking zcore in an ascending order
                     ties.method = "first")) %>% # if tie zscore, first species
  dplyr::select(sp, bioregion, zscore, rank) %>%
  mutate(zscore = round(zscore, 1)) %>% # rounding zscore to 1 digit
  as.data.frame()

knitr::kable(top10[which(top10$bioregion == "2"), ])

z_scores <- zscore(tmp, sp_col = "sp", site_col = "site",
                   bioregion_col = "bioregion", output_format = "matrix")

lambda <- interact(input_network = "projected",
                   dat = z_scores, plot = TRUE, output_format = "matrix")
knitr::kable(head(lambda[[1]]))
# Plot
lambda[[2]]
```

## Cz
Cz computation on bipartite results.

```{r cz}
bip_cz <- bip[, c("node", "module", "cat")]
colnames(bip_cz) <- c("node", "mod", "cat")

cz_bip <- cz(dat = sp_df[which(sp_df$pa > 0), ], sp_col = "sp",
             site_col = "site", bip = bip_cz, ab = NULL)

head(cz_bip[[1]])

# Interaction
# lambda <- interact(input_network = "bipartite",
#                    dat = link_cz, plot = TRUE, output_format = "matrix")
# knitr::kable(head(lambda[[1]]))
# # Plot
# lambda[[2]]

```

# Run all the steps together

All these functions can be called with the wrap-up `all_maps()` function.

```{r all_maps, eval = FALSE}
all_res <- all_maps(dat = sp_df, form = "tidy", site, sp, ab = NULL,
                    binary = TRUE,
                    similarity = "simpson", network_algo = "both",
                    saving_directory,
                    bipartite_algo = "greedy", weight = FALSE,
                    clustering = TRUE, ward_method = "ward.D2",
                    optim_method = "firstSEmax", nstart = 25, B = 50,
                    K.max = 20)
```

# References

Guimerà, R., Nunes Amaral, L. Functional cartography of complex metabolic networks. Nature 433, 895–900 (2005). https://doi.org/10.1038/nature03288

Lancichinetti A, Radicchi F, Ramasco JJ, Fortunato S (2011) Finding Statistically Significant Communities in Networks. PLoS ONE 6(4): e18961. https://doi.org/10.1371/journal.pone.0018961

Leroy, B., Meynard, C.N., Bellard, C. and Courchamp, F. (2016), virtualspecies, an R package to generate virtual species distributions. Ecography, 39: 599-607. doi:10.1111/ecog.01388
